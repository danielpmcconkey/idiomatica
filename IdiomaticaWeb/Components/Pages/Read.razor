@page "/Book/{bookid:int}/Read"
@rendermode InteractiveServer
@inject UserService UserService;
@inject IDbContextFactory<IdiomaticaContext> DbContextFactory
@using Logic.Services.API;

<style>
    span.statusUNKNOWN {
        background-color: #ed6297ff;
        color: #ffffff;
        font-weight:bold;
    }

    span.statusNEW1 {
        background-color: #3a8b89;
        color: #ffffff;
        font-weight: bold;
    }

    span.statusNEW2 {
        background-color: #6ba5a4;
        color: #032120;
        font-weight: bold;
    }

    span.statusLEARNING3 {
        background-color: #95bebd;
        color: #032120;
        font-weight: bold;
    }

    span.statusLEARNING4 {
        background-color: #bfd8d7;
        color: #032120;
        font-weight: bold;
    }

    span.statusLEARNED {
        background-color: #eaf2f1;
        color: #032120;
        text-decoration: dotted;
    }

    span.statusWELLKNOWN {
        background-color: #fff;
        color: black;
    }

    span.statusIGNORED {
        background-color: #fff;
        color: black;
    }

    .readToken {
        margin-right: .25em;
        margin-left: .25em;
        padding: .25em;
        display: inline;
        cursor: pointer;
    }
    
    .readParagraph { text-indent:2em; }
    .dissappear { display:none; }

    .unselectedWordStatus {
        border: solid 1px #cccccc;
    }

    .selectedWordStatus {
        border: solid 5px #0000ff;
    }
    
</style>

<ErrorAlert ErrorState="errorState"></ErrorAlert>
<AuthorizeView>
    <Authorized>
        
        @if (_isLoading)
        {
            <PageTitle>@UserService.GetUILabel("loading")</PageTitle>
            <Button Color="ButtonColor.Primary" Loading="true" LoadingText="@UserService.GetUILabel("loading")" />
            
        }
        else
        {
            <PageTitle>@BookTitle</PageTitle>
            <h3>@BookTitle</h3>


            <ModalWord @ref="_wModal" Parent="this" LanguageUser="_languageUser" />

            <ModalParagraph @ref="_ppModal" LanguageFromCode="_languageFromCode" LanguageToCode="_languageToCode" />





            <div class="container px-4">

                <PageTurner BookService="BookService"
                            OnMovePageAsync="OnMovePageAsync"
                            OnClearPageAsync="OnClearPageAsync"
                            BookCurrentPageNum="BookCurrentPageNum"
                            BookTotalPageCount="_bookTotalPageCount" />

                
                @foreach (var paragraph in _paragraphs)
                {
                    <hr />
                    <ParagraphView 
                        ParagraphAndChildren="paragraph"
                        OnShowWordModal="OnShowWordModal"
                        OnShowPpModal="OnShowPpModal"
                        AllWordUsersInPage="_allWordUsersInPage" />
                }
                
                <hr />
                <PageTurner OnMovePageAsync="OnMovePageAsync"
                            OnClearPageAsync="OnClearPageAsync" />
            </div>
        }
    </Authorized>
    <NotAuthorized>
        <p>@UserService.GetUILabel("notLoggedIn")</p>
    </NotAuthorized>
</AuthorizeView>


@code {

    #region parameters
    [Parameter]
    public int BookId { get; set; }
    public string? BookTitle 
    { 
        get
        {
            if (_book == null) return "";
            return _book.Title;
        } 
    }
    #endregion

    #region page loading stuff
    public ErrorState errorState = new ErrorState() { isError = false, errorMessage = "" };
    private ModalWord _wModal = default!;
    private ModalParagraph _ppModal = default!;
    private bool _isLoading = true;
    private bool _isDataInitRead = false;
    #endregion

    private Book _book;
    private User? _loggedInUser = null;
    /// <summary>
    /// the language the book is written in
    /// </summary>
    private LanguageCode? _languageFromCode = null;
    /// <summary>
    /// The user's preferred UI language
    /// </summary>
    private LanguageCode? _languageToCode = null;
    private int _bookTotalPageCount = 0;
    private BookUser? _bookUser = null;
    private List<BookUserStat>? _bookUserStats = null;
    private LanguageUser? _languageUser = null;
    private Language? _language = null;
    private Page? _currentPage = null;
    private PageUser? _currentPageUser = null;
    private Dictionary<string, Word>? _allWordsInPage = null;
    private Dictionary<string, WordUser>? _allWordUsersInPage = null;
    private List<Paragraph>? _paragraphs = null;
    private List<Sentence>? _sentences = null;
    private List<Token>? _tokens = null;
    const int LoadingDelayMiliseconds = 500;
    public int BookCurrentPageNum
    {
        get
        {
            if (_currentPage is null || _currentPage.Ordinal is null) return 0;
            return (int)_currentPage.Ordinal;
        }
    }




    protected override async Task OnInitializedAsync()
    {
        try
        {

            if (_isDataInitRead == false)
            {
                _isLoading = true;
                var t_delay = Task.Delay(LoadingDelayMiliseconds);
                await InitDataAsync();
                await t_delay;
                _isLoading = false;
            }
        }
        catch (IdiomaticaException ex)
        {
            errorState.isError = true;
            errorState.errorMessage = UserService.GetUILabel("readInitializationError");
            errorState.code = ex.code;
            errorState.memberName = ex.memberName;
            errorState.sourceFilePath = ex.sourceFilePath;
            errorState.sourceLineNumber = ex.sourceLineNumber;
            StateHasChanged();
            return;
        }
        catch (Exception ex)
        {
            errorState.isError = true;
            errorState.errorMessage = UserService.GetUILabel("readInitializationError");
            StateHasChanged();
            return;
        }
    }
    private async Task InitDataAsync()
    {
        var context = await DbContextFactory.CreateDbContextAsync();

        // tier 0 tasks, not dependent on anything
        var t_loggedInUser = UserService.GetLoggedInUserAsync(context);
        var t_book = BookApi.BookGetAsync(context, BookId);
        var t_bookTotalPageCount = BookApi.BookGetPageCountAsync(context, BookId);

        Task.WaitAll([t_loggedInUser, t_book, t_bookTotalPageCount]);

        _loggedInUser = t_loggedInUser.Result;
        _languageToCode = UserService.GetUiLanguageCode();
        _book = t_book.Result ?? new();
        _bookTotalPageCount = t_bookTotalPageCount.Result;

        if (_loggedInUser is null || _loggedInUser.Id is null || _loggedInUser.Id < 1)
        {
            ErrorHandler.LogAndThrow();
            return;
        }
        if (_languageToCode is null || string.IsNullOrEmpty(_languageToCode.Code))
        {
            ErrorHandler.LogAndThrow();
            return;
        }
        if(_book is null || _book.Id is null || _book.Id < 1 || _book.LanguageId is null || _book.LanguageId < 1)
        {
            ErrorHandler.LogAndThrow();
            return;
        }

        // tier 1 tasks, dependent on tier 0
        var t_bookUser = BookUserApi.BookUserByBookIdAndUserIdReadAsync(context, (int)_book.Id, (int)_loggedInUser.Id);
        var t_languageUser = LanguageUserApi.LanguageUserGetAsync(context, (int)_book.LanguageId, (int)_loggedInUser.Id);
        var t_language = LanguageApi.LanguageReadAsync(context, (int)_book.LanguageId);

        Task.WaitAll([t_bookUser, t_languageUser, t_language]);

        _bookUser = t_bookUser.Result;
        _languageUser = t_languageUser.Result;
        _language = t_language.Result;

        if(_bookUser is null)
        {
            // create it, I guess
            _bookUser = await CreateBookUserAsync();
        }
        if (_bookUser is null || _bookUser.Id is null || _bookUser.Id < 1)
        {
            // still null, something went wrong
            ErrorHandler.LogAndThrow();
            return;
        }
        if (_languageUser is null || _languageUser.Id is null || _languageUser.Id < 1)
        {
            ErrorHandler.LogAndThrow();
            return;
        }
        if (_language is null || _language.Id is null || _language.Id < 1 || string.IsNullOrEmpty(_language.Code))
        {
            ErrorHandler.LogAndThrow();
            return;
        }
        // tier 2, dependent on tier 1
        var t_bookUserStats = BookUserStatApi.BookUserStatsReadAsync(context, (int)_book.Id, (int)_loggedInUser.Id);
        var t_currentPageUser = PageUserApi.PageUserReadBookmarkedOrFirstAsync(context, (int)_bookUser.Id);
        var t_languageFromCode = LanguageCodeApi.LanguageCodeReadByCodeAsync(context, (string)_language.Code);

        Task.WaitAll([t_bookUserStats, t_currentPageUser, t_languageFromCode]);

        _bookUserStats = t_bookUserStats.Result;
        _currentPageUser = t_currentPageUser.Result;
        _languageFromCode = t_languageFromCode.Result;

        // create the page user if it was null from the previous call
        if (_currentPageUser is null)
        {
            // but first need to pull the page
            _currentPage = await PageApi.PageReadFirstByBookIdAsync(context, BookId);
            if (_currentPage is null || _currentPage.Id is null || _currentPage.Id < 1)
            {
                ErrorHandler.LogAndThrow();
                return;
            }
            _currentPageUser = await PageUserApi.PageUserCreateForPageIdAndUserId(
                context, (int)_currentPage.Id, (int)_loggedInUser.Id);
        }
        else
        {
            // just pull the current page
            if (_currentPageUser.PageId is null || _currentPageUser.PageId < 1)
            {
                ErrorHandler.LogAndThrow();
                return;
            }
            _currentPage = await PageApi.PageReadByIdAsync(context, (int)_currentPageUser.PageId);
        }
        if (_currentPage is null || _currentPage.Id is null || _currentPage.Id < 1)
        {
            ErrorHandler.LogAndThrow();
            return;
        }

        // tier 3, dependent on tier 2
        await PageResetDataForRead(context, (int)_currentPage.Id);

        // fin

        _isDataInitRead = true;
    }

    #region methods exposed to other elements
    public async Task OnShowWordModal(Token thisToken)
    {
        try
        {
            await _wModal.OnShowModalClick(thisToken);
        }
        catch (Exception ex)
        {
            errorState.isError = true;
            errorState.errorMessage = UserService.GetUILabel("showWordModalError");
            StateHasChanged();
            return;
        }
    }
    private async Task OnShowPpModal(Paragraph pp)
    {
        try
        {
            await _ppModal.OnShowPpModalClick(pp);
        }
        catch (Exception ex)
        {
            errorState.isError = true;
            errorState.errorMessage = UserService.GetUILabel("showPpModalError");
            StateHasChanged();
            return;
        }
    }
    private async Task OnMovePageAsync(int targetPageNum)
    {
        try
        {
            _isLoading = true;
            // force a delay of at least N miliseconds. this forces the screen
            // to re-draw the paragraphs. Otherwise, you get the old paragraphs
            // on the new page.
            var t_delay = Task.Delay(LoadingDelayMiliseconds);
            var context = await DbContextFactory.CreateDbContextAsync(); 
            await PageMove(context, targetPageNum);
            await t_delay;
            _isLoading = false;

        }
        catch (IdiomaticaException ex)
        {
            errorState.isError = true;
            errorState.errorMessage = UserService.GetUILabel("readErrorPageChange");
            errorState.code = ex.code;
            errorState.memberName = ex.memberName;
            errorState.sourceFilePath = ex.sourceFilePath;
            errorState.sourceLineNumber = ex.sourceLineNumber;
            StateHasChanged();
            return;
        }
        catch (Exception ex)
        {
            errorState.isError = true;
            errorState.errorMessage = UserService.GetUILabel("readErrorPageChange");
            StateHasChanged();
            return;
        }
    }
    private async Task OnClearPageAsync(int targetPageNum)
    {
        try
        {
            _isLoading = true;
            // force a delay of at least N miliseconds. this forces the screen
            // to re-draw the paragraphs. Otherwise, you get the old paragraphs
            // on the new page.
            var t_delay = Task.Delay(1000); 
            var context = await DbContextFactory.CreateDbContextAsync();
            if(_currentPageUser is null || _currentPageUser.Id is null || _currentPageUser.Id < 1)
            {
                ErrorHandler.LogAndThrow();
                return;
            }
            // update all unknowns to well known
            await PageUserApi.PageUserUpdateUnknowWordsToWellKnown(context, (int)_currentPageUser.Id);
            // now move forward, if there's another page
            if (targetPageNum <= _bookTotalPageCount) // remember pages are 1-indexed
            {
                await PageMove(context, targetPageNum);
            }
            else
            {
                // mark the previous page as read because you didn't do it in the PageMove function
                await PageUserApi.PageUserMarkAsReadAsync(context, (int)_currentPageUser.Id);
                // refresh the word user cache
                await PageResetDataForRead(context, (int)_currentPageUser.Id);
            }

            await t_delay;
            _isLoading = false;
        }
        catch (IdiomaticaException ex)
        {
            errorState.isError = true;
            errorState.errorMessage = UserService.GetUILabel("clearPageUserError");
            errorState.code = ex.code;
            errorState.memberName = ex.memberName;
            errorState.sourceFilePath = ex.sourceFilePath;
            errorState.sourceLineNumber = ex.sourceLineNumber;
            StateHasChanged();
            return;
        }
        catch (Exception ex)
        {
            errorState.isError = true;
            errorState.errorMessage = UserService.GetUILabel("clearPageUserError");
            StateHasChanged();
            return;
        }
    }
    public void RefreshState() { StateHasChanged(); }
    private async Task PageResetDataForRead(IdiomaticaContext context, int pageId)
    {
        if (pageId < 1)
        {
            ErrorHandler.LogAndThrow(1240);
            return;
        }
        if (_loggedInUser == null || _loggedInUser.Id == null || _loggedInUser.Id == 0)
        {
            ErrorHandler.LogAndThrow(2130);
            return;
        }
        // wipe the old ones out
        _currentPage = null;
        _paragraphs = null;
        _allWordUsersInPage = null;
        _allWordsInPage = null;
        _sentences = null;
        _tokens = null;

        // and rebuild
        var t_currentPage = PageApi.PageReadByIdAsync(context, pageId);
        var t_paragraphs = ParagraphApi.ParagraphsReadByPageIdAsync(context, pageId);
        var t_wordsInPage = WordApi.WordsDictReadByPageIdAsync(context, pageId);
        var t_sentencesInPage = SentenceApi.SentencesReadByPageIdAsync(context, pageId);
        var t_tokensInPage = TokenApi.TokensReadByPageIdAsync(context, pageId);

        Task.WaitAll([t_currentPage, t_paragraphs, t_wordsInPage, t_sentencesInPage, t_tokensInPage]);

        _currentPage = t_currentPage.Result;
        _paragraphs = t_paragraphs.Result;
        _allWordsInPage = t_wordsInPage.Result;
        _sentences = t_sentencesInPage.Result;
        _tokens = t_tokensInPage.Result;

        if (_allWordsInPage is null)
        {
            ErrorHandler.LogAndThrow(2130);
            return;
        }

        // do not do this until you've already pulled the _allWordsInPage as 
        // that makes it way more efficient since it checks the words dict cache
        _allWordUsersInPage = await WordUserApi.WordUsersDictByPageIdAndUserIdReadAsync(
            context, pageId, (int)_loggedInUser.Id);

        if (_allWordUsersInPage is null)
        {
            ErrorHandler.LogAndThrow(2130);
            return;
        }
        if (_paragraphs is null)
        {
            ErrorHandler.LogAndThrow(2130);
            return;
        }

        // now knit the paragraph data together

        foreach (var p in _paragraphs)
        {
            p.Sentences = NullHandler.ThrowIfNullOrEmptyList<Sentence>(_sentences)
                .Where(s => s.ParagraphId == p.Id)
                .OrderBy(s => s.Ordinal)
                .ToList();
            foreach (var s in p.Sentences)
            {
                s.Tokens = NullHandler.ThrowIfNullOrEmptyList<Token>(_tokens)
                    .Where(t => t.SentenceId == s.Id)
                    .OrderBy(t => t.Ordinal)
                    .ToList();

                foreach (var t in s.Tokens)
                {
                    var wordEntry = NullHandler.ThrowIfNullOrEmptyDict(_allWordsInPage)
                        .Where(w => w.Value.Id == t.WordId)
                        .FirstOrDefault();
                    if (wordEntry.Value != null)
                    {
                        t.Word = wordEntry.Value;
                    }
                }
            }
        }


    }
    private async Task PageMove(IdiomaticaContext context, int targetPageNum)
    {
        _isDataInitRead = false;

        if (_languageUser is null || _languageUser.Id is null || _languageUser.Id < 1)
        {
            ErrorHandler.LogAndThrow();
            return;
        }
        if (_currentPageUser is null || _currentPageUser.Id is null || _currentPageUser.Id < 1)
        {
            ErrorHandler.LogAndThrow();
            return;
        }
        if (_bookUser is null || _bookUser.Id is null || _bookUser.Id < 1)
        {
            ErrorHandler.LogAndThrow();
            return;
        }

        // mark the previous page as read before moving on

        await PageUserApi.PageUserMarkAsReadAsync(context, (int)_currentPageUser.Id);

        if (targetPageNum < 1) return;
        if (targetPageNum > _bookTotalPageCount)
            return;

        // reload the current page user with the new target
        _currentPageUser = await PageUserApi.PageUserReadByOrderWithinBookAsync(
            context, (int)_languageUser.Id, targetPageNum, BookId);
        if (_currentPageUser is null || _currentPageUser.PageId is null) 
        {
            // should we throw an exception? keep an eye here
            return;
        }

        await PageResetDataForRead(context, (int)_currentPageUser.PageId);
        await BookUserApi.BookUserUpdateBookmarkAsync(context, (int)_bookUser.Id, (int)_currentPageUser.PageId);
        _isDataInitRead = true;
    }
    private async Task<BookUser?> CreateBookUserAsync()
    {
        var context = await DbContextFactory.CreateDbContextAsync();
        await context.Database.BeginTransactionAsync();
        try
        {
            if (_loggedInUser is null || _loggedInUser.Id is null)
            {
                ErrorHandler.LogAndThrow();
                return null;
            }

            // create the base bookUser
            var bookUser = await BookUserApi.BookUserCreateAsync(context, BookId, (int)_loggedInUser.Id);
            if (bookUser is null || bookUser.Id is null)
            {
                ErrorHandler.LogAndThrow();
                return null;
            }
            // create the wordUsers
            await WordUserApi.WordUsersCreateAllForBookIdAndUserIdAsync(context, BookId, (int)_loggedInUser.Id);
            // update bookUserStats
            await BookUserStatApi.BookUserStatsUpdateByBookUserIdAsync(context, (int)bookUser.Id);
            // finally commit the write
            await context.Database.CommitTransactionAsync();
            return bookUser;
        }
        catch (IdiomaticaException ex)
        {
            await context.Database.RollbackTransactionAsync();
            errorState.isError = true;
            errorState.errorMessage = UserService.GetUILabel("bookListRemoveBookError");
            errorState.code = ex.code;
            errorState.memberName = ex.memberName;
            errorState.sourceFilePath = ex.sourceFilePath;
            errorState.sourceLineNumber = ex.sourceLineNumber;
            StateHasChanged();
            return null;
        }
    }
    #endregion
}
